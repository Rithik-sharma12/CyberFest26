(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push(["object" == typeof document ? document.currentScript : void 0, 29731, t => {
    "use strict";

    function e(t, e, i) {
        return Math.max(t, Math.min(e, i))
    }
    class i {
        advance(t) {
            var i, s, o, n;
            if (!this.isRunning) return;
            let l = !1;
            if (this.lerp) this.value = (i = this.value, s = this.to, o = 60 * this.lerp, (1 - (n = 1 - Math.exp(-o * t))) * i + n * s), Math.round(this.value) === this.to && (this.value = this.to, l = !0);
            else {
                this.currentTime += t;
                let i = e(0, this.currentTime / this.duration, 1),
                    s = (l = i >= 1) ? 1 : this.easing(i);
                this.value = this.from + (this.to - this.from) * s
            }
            this.onUpdate ? .(this.value, l), l && this.stop()
        }
        stop() {
            this.isRunning = !1
        }
        fromTo(t, e, {
            lerp: i = .1,
            duration: s = 1,
            easing: o = t => t,
            onStart: n,
            onUpdate: l
        }) {
            this.from = this.value = t, this.to = e, this.lerp = i, this.duration = s, this.easing = o, this.currentTime = 0, this.isRunning = !0, n ? .(), this.onUpdate = l
        }
    }
    class s {
        constructor({
            wrapper: t,
            content: e,
            autoResize: i = !0,
            debounce: s = 250
        } = {}) {
            this.wrapper = t, this.content = e, i && (this.debouncedResize = function(t, e) {
                let i;
                return function() {
                    let s = arguments,
                        o = this;
                    clearTimeout(i), i = setTimeout(function() {
                        t.apply(o, s)
                    }, e)
                }
            }(this.resize, s), this.wrapper === window ? window.addEventListener("resize", this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(this.debouncedResize), this.contentResizeObserver.observe(this.content)), this.resize()
        }
        destroy() {
            this.wrapperResizeObserver ? .disconnect(), this.contentResizeObserver ? .disconnect(), window.removeEventListener("resize", this.debouncedResize, !1)
        }
        resize = () => {
            this.onWrapperResize(), this.onContentResize()
        };
        onWrapperResize = () => {
            this.wrapper === window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight)
        };
        onContentResize = () => {
            this.wrapper === window ? (this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth) : (this.scrollHeight = this.wrapper.scrollHeight, this.scrollWidth = this.wrapper.scrollWidth)
        };
        get limit() {
            return {
                x: this.scrollWidth - this.width,
                y: this.scrollHeight - this.height
            }
        }
    }
    class o {
        constructor() {
            this.events = {}
        }
        emit(t, ...e) {
            let i = this.events[t] || [];
            for (let t = 0, s = i.length; t < s; t++) i[t](...e)
        }
        on(t, e) {
            return this.events[t] ? .push(e) || (this.events[t] = [e]), () => {
                this.events[t] = this.events[t] ? .filter(t => e !== t)
            }
        }
        off(t, e) {
            this.events[t] = this.events[t] ? .filter(t => e !== t)
        }
        destroy() {
            this.events = {}
        }
    }
    let n = 100 / 6;
    class l {
        constructor(t, {
            wheelMultiplier: e = 1,
            touchMultiplier: i = 1
        }) {
            this.element = t, this.wheelMultiplier = e, this.touchMultiplier = i, this.touchStart = {
                x: null,
                y: null
            }, this.emitter = new o, window.addEventListener("resize", this.onWindowResize, !1), this.onWindowResize(), this.element.addEventListener("wheel", this.onWheel, {
                passive: !1
            }), this.element.addEventListener("touchstart", this.onTouchStart, {
                passive: !1
            }), this.element.addEventListener("touchmove", this.onTouchMove, {
                passive: !1
            }), this.element.addEventListener("touchend", this.onTouchEnd, {
                passive: !1
            })
        }
        on(t, e) {
            return this.emitter.on(t, e)
        }
        destroy() {
            this.emitter.destroy(), window.removeEventListener("resize", this.onWindowResize, !1), this.element.removeEventListener("wheel", this.onWheel, {
                passive: !1
            }), this.element.removeEventListener("touchstart", this.onTouchStart, {
                passive: !1
            }), this.element.removeEventListener("touchmove", this.onTouchMove, {
                passive: !1
            }), this.element.removeEventListener("touchend", this.onTouchEnd, {
                passive: !1
            })
        }
        onTouchStart = t => {
            let {
                clientX: e,
                clientY: i
            } = t.targetTouches ? t.targetTouches[0] : t;
            this.touchStart.x = e, this.touchStart.y = i, this.lastDelta = {
                x: 0,
                y: 0
            }, this.emitter.emit("scroll", {
                deltaX: 0,
                deltaY: 0,
                event: t
            })
        };
        onTouchMove = t => {
            let {
                clientX: e,
                clientY: i
            } = t.targetTouches ? t.targetTouches[0] : t, s = -(e - this.touchStart.x) * this.touchMultiplier, o = -(i - this.touchStart.y) * this.touchMultiplier;
            this.touchStart.x = e, this.touchStart.y = i, this.lastDelta = {
                x: s,
                y: o
            }, this.emitter.emit("scroll", {
                deltaX: s,
                deltaY: o,
                event: t
            })
        };
        onTouchEnd = t => {
            this.emitter.emit("scroll", {
                deltaX: this.lastDelta.x,
                deltaY: this.lastDelta.y,
                event: t
            })
        };
        onWheel = t => {
            let {
                deltaX: e,
                deltaY: i,
                deltaMode: s
            } = t;
            e *= 1 === s ? n : 2 === s ? this.windowWidth : 1, i *= 1 === s ? n : 2 === s ? this.windowHeight : 1, e *= this.wheelMultiplier, i *= this.wheelMultiplier, this.emitter.emit("scroll", {
                deltaX: e,
                deltaY: i,
                event: t
            })
        };
        onWindowResize = () => {
            this.windowWidth = window.innerWidth, this.windowHeight = window.innerHeight
        }
    }
    class r {
        constructor({
            wrapper: t = window,
            content: e = document.documentElement,
            wheelEventsTarget: n = t,
            eventsTarget: r = n,
            smoothWheel: h = !0,
            syncTouch: a = !1,
            syncTouchLerp: c = .075,
            touchInertiaMultiplier: d = 35,
            duration: p,
            easing: u = t => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
            lerp: m = !p && .1,
            infinite: g = !1,
            orientation: v = "vertical",
            gestureOrientation: S = "vertical",
            touchMultiplier: w = 1,
            wheelMultiplier: f = 1,
            autoResize: _ = !0,
            __experimental__naiveDimensions: z = !1
        } = {}) {
            this.__isSmooth = !1, this.__isScrolling = !1, this.__isStopped = !1, this.__isLocked = !1, this.onVirtualScroll = ({
                deltaX: t,
                deltaY: e,
                event: i
            }) => {
                if (i.ctrlKey) return;
                let s = i.type.includes("touch"),
                    o = i.type.includes("wheel");
                if (this.options.syncTouch && s && "touchstart" === i.type && !this.isStopped && !this.isLocked) return void this.reset();
                let n = "vertical" === this.options.gestureOrientation && 0 === e || "horizontal" === this.options.gestureOrientation && 0 === t;
                if (0 === t && 0 === e || n) return;
                let l = i.composedPath();
                if ((l = l.slice(0, l.indexOf(this.rootElement))).find(t => {
                        var e, i, n, l, r;
                        return (null == (e = t.hasAttribute) ? void 0 : e.call(t, "data-lenis-prevent")) || s && (null == (i = t.hasAttribute) ? void 0 : i.call(t, "data-lenis-prevent-touch")) || o && (null == (n = t.hasAttribute) ? void 0 : n.call(t, "data-lenis-prevent-wheel")) || (null == (l = t.classList) ? void 0 : l.contains("lenis")) && !(null == (r = t.classList) ? void 0 : r.contains("lenis-stopped"))
                    })) return;
                if (this.isStopped || this.isLocked) return void i.preventDefault();
                if (this.isSmooth = this.options.syncTouch && s || this.options.smoothWheel && o, !this.isSmooth) return this.isScrolling = !1, void this.animate.stop();
                i.preventDefault();
                let r = e;
                "both" === this.options.gestureOrientation ? r = Math.abs(e) > Math.abs(t) ? e : t : "horizontal" === this.options.gestureOrientation && (r = t);
                let h = s && this.options.syncTouch,
                    a = s && "touchend" === i.type && Math.abs(r) > 5;
                a && (r = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + r, Object.assign({
                    programmatic: !1
                }, h ? {
                    lerp: a ? this.options.syncTouchLerp : 1
                } : {
                    lerp: this.options.lerp,
                    duration: this.options.duration,
                    easing: this.options.easing
                }))
            }, this.onNativeScroll = () => {
                if (!this.__preventNextScrollEvent && !this.isScrolling) {
                    let t = this.animatedScroll;
                    this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.direction = Math.sign(this.animatedScroll - t), this.emit()
                }
            }, window.lenisVersion = "1.0.42", t !== document.documentElement && t !== document.body || (t = window), this.options = {
                wrapper: t,
                content: e,
                wheelEventsTarget: n,
                eventsTarget: r,
                smoothWheel: h,
                syncTouch: a,
                syncTouchLerp: c,
                touchInertiaMultiplier: d,
                duration: p,
                easing: u,
                lerp: m,
                infinite: g,
                gestureOrientation: S,
                orientation: v,
                touchMultiplier: w,
                wheelMultiplier: f,
                autoResize: _,
                __experimental__naiveDimensions: z
            }, this.animate = new i, this.emitter = new o, this.dimensions = new s({
                wrapper: t,
                content: e,
                autoResize: _
            }), this.toggleClassName("lenis", !0), this.velocity = 0, this.isLocked = !1, this.isStopped = !1, this.isSmooth = a || h, this.isScrolling = !1, this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener("scroll", this.onNativeScroll, !1), this.virtualScroll = new l(r, {
                touchMultiplier: w,
                wheelMultiplier: f
            }), this.virtualScroll.on("scroll", this.onVirtualScroll)
        }
        destroy() {
            this.emitter.destroy(), this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, !1), this.virtualScroll.destroy(), this.dimensions.destroy(), this.toggleClassName("lenis", !1), this.toggleClassName("lenis-smooth", !1), this.toggleClassName("lenis-scrolling", !1), this.toggleClassName("lenis-stopped", !1), this.toggleClassName("lenis-locked", !1)
        }
        on(t, e) {
            return this.emitter.on(t, e)
        }
        off(t, e) {
            return this.emitter.off(t, e)
        }
        setScroll(t) {
            this.isHorizontal ? this.rootElement.scrollLeft = t : this.rootElement.scrollTop = t
        }
        resize() {
            this.dimensions.resize()
        }
        emit() {
            this.emitter.emit("scroll", this)
        }
        reset() {
            this.isLocked = !1, this.isScrolling = !1, this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.animate.stop()
        }
        start() {
            this.isStopped && (this.isStopped = !1, this.reset())
        }
        stop() {
            this.isStopped || (this.isStopped = !0, this.animate.stop(), this.reset())
        }
        raf(t) {
            let e = t - (this.time || t);
            this.time = t, this.animate.advance(.001 * e)
        }
        scrollTo(t, {
            offset: i = 0,
            immediate: s = !1,
            lock: o = !1,
            duration: n = this.options.duration,
            easing: l = this.options.easing,
            lerp: r = !n && this.options.lerp,
            onComplete: h,
            force: a = !1,
            programmatic: c = !0
        } = {}) {
            if (!this.isStopped && !this.isLocked || a) {
                if (["top", "left", "start"].includes(t)) t = 0;
                else if (["bottom", "right", "end"].includes(t)) t = this.limit;
                else {
                    let e;
                    if ("string" == typeof t ? e = document.querySelector(t) : (null == t ? void 0 : t.nodeType) && (e = t), e) {
                        if (this.options.wrapper !== window) {
                            let t = this.options.wrapper.getBoundingClientRect();
                            i -= this.isHorizontal ? t.left : t.top
                        }
                        let s = e.getBoundingClientRect();
                        t = (this.isHorizontal ? s.left : s.top) + this.animatedScroll
                    }
                }
                if ("number" == typeof t) {
                    if (t += i, t = Math.round(t), this.options.infinite ? c && (this.targetScroll = this.animatedScroll = this.scroll) : t = e(0, t, this.limit), s) return this.animatedScroll = this.targetScroll = t, this.setScroll(this.scroll), this.reset(), void(null == h || h(this));
                    if (!c) {
                        if (t === this.targetScroll) return;
                        this.targetScroll = t
                    }
                    this.animate.fromTo(this.animatedScroll, t, {
                        duration: n,
                        easing: l,
                        lerp: r,
                        onStart: () => {
                            o && (this.isLocked = !0), this.isScrolling = !0
                        },
                        onUpdate: (t, e) => {
                            this.isScrolling = !0, this.velocity = t - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = t, this.setScroll(this.scroll), c && (this.targetScroll = t), e || this.emit(), e && (this.reset(), this.emit(), null == h || h(this), this.__preventNextScrollEvent = !0, requestAnimationFrame(() => {
                                delete this.__preventNextScrollEvent
                            }))
                        }
                    })
                }
            }
        }
        get rootElement() {
            return this.options.wrapper === window ? document.documentElement : this.options.wrapper
        }
        get limit() {
            return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"]
        }
        get isHorizontal() {
            return "horizontal" === this.options.orientation
        }
        get actualScroll() {
            return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop
        }
        get scroll() {
            var t;
            return this.options.infinite ? (this.animatedScroll % (t = this.limit) + t) % t : this.animatedScroll
        }
        get progress() {
            return 0 === this.limit ? 1 : this.scroll / this.limit
        }
        get isSmooth() {
            return this.__isSmooth
        }
        set isSmooth(t) {
            this.__isSmooth !== t && (this.__isSmooth = t, this.toggleClassName("lenis-smooth", t))
        }
        get isScrolling() {
            return this.__isScrolling
        }
        set isScrolling(t) {
            this.__isScrolling !== t && (this.__isScrolling = t, this.toggleClassName("lenis-scrolling", t))
        }
        get isStopped() {
            return this.__isStopped
        }
        set isStopped(t) {
            this.__isStopped !== t && (this.__isStopped = t, this.toggleClassName("lenis-stopped", t))
        }
        get isLocked() {
            return this.__isLocked
        }
        set isLocked(t) {
            this.__isLocked !== t && (this.__isLocked = t, this.toggleClassName("lenis-locked", t))
        }
        get className() {
            let t = "lenis";
            return this.isStopped && (t += " lenis-stopped"), this.isLocked && (t += " lenis-locked"), this.isScrolling && (t += " lenis-scrolling"), this.isSmooth && (t += " lenis-smooth"), t
        }
        toggleClassName(t, e) {
            this.rootElement.classList.toggle(t, e), this.emitter.emit("className change", this)
        }
    }
    t.s(["default", () => r])
}]);